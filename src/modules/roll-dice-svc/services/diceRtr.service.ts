/**
 * Generated by ForkLaunch
 * File: diceRtr.service.ts
 * This is an auto-generated file. Modifications are encouraged but may inhibit automated upgrades.
 */

import { Metrics } from '@dice-roll-node-app/monitoring';
import { OpenTelemetryCollector } from '@forklaunch/core/http';
import { EntityManager } from '@mikro-orm/core';
import { DiceRtrService } from '../domain/interfaces/diceRtr.interface';
import {
  DiceRtrRollRequestDto,
  DiceRtrRollResponseDto,
  DiceRtrStatsResponseDto
} from '../domain/types/diceRtr.types';

import {
  DiceRtrRollRequestMapper,
  DiceRtrRollResponseMapper
} from '../domain/mappers/diceRtr.mappers';
import { DiceRtrRecord } from '../persistence/entities/diceRtrRecord.entity';

export class BaseDiceRtrService implements DiceRtrService {
  private entityManager: EntityManager;
  private readonly openTelemetryCollector: OpenTelemetryCollector<Metrics>;

  constructor(
    entityManager: EntityManager,
    openTelemetryCollector: OpenTelemetryCollector<Metrics>
  ) {
    this.entityManager = entityManager;
    this.openTelemetryCollector = openTelemetryCollector;
  }

  diceRtrRoll = async (
    dto: DiceRtrRollRequestDto
  ): Promise<DiceRtrRollResponseDto> => {
    // Validate die type
    const sides = parseInt(dto.dieType.replace('d', ''));
    if (isNaN(sides) || sides < 2) {
      throw new Error(`Invalid die type: ${dto.dieType}. Use format d4, d6, d12, d20, etc.`);
    }

    // Create entity with roll result
    const entity = await DiceRtrRollRequestMapper.toEntity(
      dto,
      this.entityManager
    );

    // Save to database
    await this.entityManager.persistAndFlush(entity);

    this.openTelemetryCollector.info('Dice rolled', {
      dieType: dto.dieType,
      result: entity.result
    });

    return DiceRtrRollResponseMapper.toDto(entity);
  };

  diceRtrStats = async (): Promise<DiceRtrStatsResponseDto> => {
    // Get all rolls
    const allRolls = await this.entityManager.find(DiceRtrRecord, {});

    // Group by die type and calculate stats
    const byDieType: Record<string, { count: number; average: number; min: number; max: number }> = {};

    allRolls.forEach(roll => {
      if (!byDieType[roll.dieType]) {
        byDieType[roll.dieType] = {
          count: 0,
          average: 0,
          min: Infinity,
          max: -Infinity
        };
      }

      const stats = byDieType[roll.dieType];
      stats.count++;
      stats.min = Math.min(stats.min, roll.result);
      stats.max = Math.max(stats.max, roll.result);
    });

    // Calculate averages
    Object.keys(byDieType).forEach(dieType => {
      const rolls = allRolls.filter(r => r.dieType === dieType);
      const sum = rolls.reduce((acc, r) => acc + r.result, 0);
      byDieType[dieType].average = sum / rolls.length;
    });

    return {
      totalRolls: allRolls.length,
      byDieType
    };
  };
}