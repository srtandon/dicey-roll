/**
 * Generated by ForkLaunch
 * File: diceRtr.test.ts
 * This is an auto-generated file. Modifications are encouraged but may inhibit automated upgrades.
 */

import {
  cleanupTestDatabase,
  clearDatabase,
  mockDiceRtrData,
  setupTestData,
  setupTestDatabase,
  TestSetupResult
} from './test-utils';

describe('DiceRtr Routes E2E Tests', () => {
  let orm: TestSetupResult['orm'];




  beforeAll(async () => {
    const setup = await setupTestDatabase();
    orm = setup.orm;



  }, 60000);

  beforeEach(async () => {
    await clearDatabase({ orm });
    if (!orm) throw new Error('ORM not initialized');
    const em = orm.em.fork();
    await setupTestData(em);
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  }, 30000);

  describe('GET /diceRtr - diceRtrGet', () => {
    it('should handle diceRtr get request successfully', async () => {
      const { diceRtrGetRoute } = await import(
        '../api/routes/diceRtr.routes'
      );

      const response = await diceRtrGetRoute.sdk.diceRtrGet();

      expect(response.code).toBe(200);
      expect(response.response).toBeDefined();
    });
  });

  describe('POST /diceRtr - diceRtrPost', () => {
    it('should handle diceRtr request successfully', async () => {
      const { diceRtrPostRoute } = await import(
        '../api/routes/diceRtr.routes'
      );

      const response = await diceRtrPostRoute.sdk.diceRtrPost({
        body: mockDiceRtrData
      });

      expect(response.code).toBe(200);
      expect(response.response).toBeDefined();
      if (response.code === 200) {
        expect(response.response.message).toBeDefined();
      }
    });

    it('should handle validation errors', async () => {
      const { diceRtrPostRoute } = await import(
        '../api/routes/diceRtr.routes'
      );

      const invalidData = {
        message: ''
      };

      try {
        await diceRtrPostRoute.sdk.diceRtrPost({
          body: invalidData
        });
        expect(true).toBe(false);
      } catch (error: unknown) {
        expect(error).toBeDefined();
      }
    });


    it('should persist data to database', async () => {
      const { diceRtrPostRoute } = await import(
        '../api/routes/diceRtr.routes'
      );

      await diceRtrPostRoute.sdk.diceRtrPost({
        body: mockDiceRtrData
      });

      if (!orm) throw new Error('ORM not initialized');
      const em = orm.em.fork();
      const { DiceRtrRecord } = await import(
        '../persistence/entities/diceRtrRecord.entity'
      );

      // Since diceRtrPost now just returns "hello, world!" without persisting,
      // we can't test persistence here. Instead, we'll just verify the endpoint works.
      // If you want to test persistence, use the diceRtrRoll endpoint instead.
      const records = await em.find(DiceRtrRecord, {});

      // The diceRtrPost endpoint doesn't persist data anymore, so we just check it exists
      expect(records).toBeDefined();
    });

  });

  describe('POST /dice-rtr/roll - diceRtrRoll', () => {
    it('should roll a dice successfully', async () => {
      const { diceRtrRollRoute } = await import(
        '../api/routes/diceRtr.routes'
      );

      const response = await diceRtrRollRoute.sdk.rollDice({
        body: { dieType: 'd6' }
      });

      expect(response.code).toBe(200);
      expect(response.response).toBeDefined();
      if (response.code === 200) {
        expect(response.response.dieType).toBe('d6');
        expect(response.response.result).toBeGreaterThanOrEqual(1);
        expect(response.response.result).toBeLessThanOrEqual(6);
        expect(response.response.id).toBeDefined();
        expect(response.response.createdAt).toBeDefined();
      }
    });

    it('should roll different die types', async () => {
      const { diceRtrRollRoute } = await import(
        '../api/routes/diceRtr.routes'
      );

      const dieTypes = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];

      for (const dieType of dieTypes) {
        const response = await diceRtrRollRoute.sdk.rollDice({
          body: { dieType }
        });

        expect(response.code).toBe(200);
        if (response.code === 200) {
          expect(response.response.dieType).toBe(dieType);
          const maxValue = parseInt(dieType.replace('d', ''));
          expect(response.response.result).toBeGreaterThanOrEqual(1);
          expect(response.response.result).toBeLessThanOrEqual(maxValue);
        }
      }
    });

    it('should persist dice roll to database', async () => {
      const { diceRtrRollRoute } = await import(
        '../api/routes/diceRtr.routes'
      );

      const response = await diceRtrRollRoute.sdk.rollDice({
        body: { dieType: 'd6' }
      });

      expect(response.code).toBe(200);

      if (!orm) throw new Error('ORM not initialized');
      const em = orm.em.fork();
      const { DiceRtrRecord } = await import(
        '../persistence/entities/diceRtrRecord.entity'
      );

      const records = await em.find(DiceRtrRecord, {
        dieType: 'd6'
      });

      expect(records.length).toBeGreaterThan(0);
      const lastRecord = records[records.length - 1];
      expect(lastRecord.dieType).toBe('d6');
      expect(lastRecord.result).toBeGreaterThanOrEqual(1);
      expect(lastRecord.result).toBeLessThanOrEqual(6);
    });

    it('should handle validation errors for invalid die types', async () => {
      const { diceRtrRollRoute } = await import(
        '../api/routes/diceRtr.routes'
      );

      const invalidDieTypes = ['d1', 'd0', 'invalid', 'd', ''];

      for (const invalidDieType of invalidDieTypes) {
        try {
          await diceRtrRollRoute.sdk.rollDice({
            body: { dieType: invalidDieType }
          });
          // If we get here, the validation didn't work as expected
          expect(true).toBe(false);
        } catch (error: unknown) {
          expect(error).toBeDefined();
        }
      }
    });
  });
});